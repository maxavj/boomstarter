<?php 

/**
 * @file
 * Hooks and documentation related to the theme and render system.
 *
 *
 * @see hooks
 * @see callbacks
 * @see theme_render
 */
function template_preprocess_views_view__users_in_site(&$variables) {
  $view = $variables['view'];
  $id = $view->storage->id();
  $variables['id'] = $id;
  $variables['display_id'] = $view->current_display;
  // Override the title to be empty by default. For example, if viewing a page
  // view, 'title' will already be populated in $variables. This can still be
  // overridden to use a title when needed. See views_ui_preprocess_views_view()
  // for an example of this.
  $variables['title'] = 'users_in_site';

  $css_class = $view->display_handler->getOption('css_class');
  if (!empty($css_class)) {
    $variables['css_class'] = preg_replace('/[^a-zA-Z0-9- ]/', '-', $css_class);
    $variables['attributes']['class'][] = $variables['css_class'];
  }

  // contextual_preprocess() only works on render elements, and since this theme
  // hook is not for a render element, contextual_preprocess() falls back to the
  // first argument and checks if that is a render element. The first element is
  // view_array. However, view_array does not get set anywhere, but since we do
  // have access to the View object, we can also access the View object's
  // element, which is a render element that does have #contextual_links set if
  // the display supports it. Doing this allows contextual_preprocess() to
  // access this theme hook's render element, and therefore allows this template
  // to have contextual links.
  // @see views_theme()
  $variables['view_array'] = $variables['view']->element;

  // Attachments are always updated with the outer view, never by themselves,
  // so they do not have dom ids.
  if (empty($view->is_attachment)) {
    // Our JavaScript needs to have some means to find the HTML belonging to
    // this view.
    //
    // It is true that the DIV wrapper has classes denoting the name of the view
    // and its display ID, but this is not enough to unequivocally match a view
    // with its HTML, because one view may appear several times on the page. So
    // we set up a hash with the current time, $dom_id, to issue a "unique"
    // identifier for each view. This identifier is written to both
    // drupalSettings and the DIV wrapper.
    $variables['dom_id'] = $view->dom_id;
  }
  $users = '1';
  $variables['users'] = t('1');
  print_r($id);
}